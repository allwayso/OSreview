---
title: 进程线程模型
author: Allwayso
update: 2025-12-20
status: Completed
---

---

## CPU调度基本模型

### 就绪队列

就绪队列不同于普通队列，将任务按调度算法决定组织方式和取出顺序

### 中断条件

其实就是异常和外中断

### 调度器的作用

选择下一个执行的任务；决定执行该任务的时间片长短和核心

---

## 调度器的指标

吞吐量（单位时间内执行的任务数量），周转时间（任务发起到执行结束的时间），响应时间（从发起到首次执行的时间），公平性（长时任务不应该一直占用CPU，也不能一直饥饿），资源利用率（CPU利用率）

---

## 单级调度算法

单极调度算法可以分为抢占式和非抢占式，是复杂多级调度算法的基础

### 先来先服务（FCFS）

简单的队列实现，非抢占式，按时间顺序执行任务

优点：实现简单

缺点：遇到长时间任务会导致车队效应，吞吐量得不到保证

### 最短作业优先（SJF）

执行前预估作业时间，优先执行用时最短的任务

优点：最优的非抢占式调度算法，平均等待时间和平均周转时间最短

缺点：预估作业时间不可能准确实现；长时任务的“饥饿”没有被考虑，丧失公平性

### 剩余时间最短（SRTF）

SJF的抢占式版本，新任务入队或者有进程从阻塞态进入等待态时，若该任务所需的剩余时间更短，则立即抢占当前进程

优点：理论上平均周转时间最短

缺点：频繁的上下文切换；没有根本上改变SJF中无法准确预测运行时间的问题

### 优先级调度（priority scheduling）

不同于先前的三个算法，该算法通过优先级来执行任务，而非运行时间或者入队顺序

优点：符合实际需求，所有任务并不是同等重要，重要的任务可以优先执行

缺点：低优先级任务饥饿

### 时间片轮转（round-robin）

对FCFS的抢占式优化，只要时间片用尽就切换到下一个任务

优点：避免长时任务占据CPU，公平性极高，响应时间短

缺点：效率取决于时间片与运行时间的相对关系，若时间片大于运行时间则退化为FCFS；若时间片过小则上下文切换开销大

### 最高响应比优先（highest response radio next)

非抢占式算法，是对SJF的优化，用等待时间和服务时间共同刻画响应比，兼顾短作业优先和公平性，部分缓解饥饿问题

优点：比SJF公平，比FCFS效率高

缺点：没有解决SJF不能准确估计“服务时间”的问题，而且响应比需要随等待时间变化而更新，每次都需要对等待队列重排，效率低

---

## 多级调度算法

单级调度算法各有优缺点，我希望对于不同的任务使用不同的处理方法，所以将单个队列变为按优先级分的多个队列，在队列内部采取不同算法，在队列间优先执行高优先级队列

### 队列结构

高优先级队列：系统进程或交互型进程，需要频繁I/O中断，使用时间片轮转比较合适

中优先级队列：后台服务，少量I/O中断，依然使用时间片轮转

低优先级队列：批处理任务，几乎无I/O中断，采用FCFS，此时队列内部的饥饿是合适的

### 优点：

| **单级算法**         | **主要不足/局限性**                                                          | **MLQ 如何解决（或综合利用）**                                                                                                            |
| ---------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **FCFS** (先来先服务) | **效率问题**：存在**“车队效应”**（长作业阻塞短作业），导致**平均等待时间过长**。                       | **将 FCFS 降级使用：** MLQ 只在**低优先级/批处理队列**中使用 FCFS。这些队列里的任务都是计算密集型、可容忍等待的，使用 FCFS 可以消除切换开销，最大化**吞吐量**。而短作业被分配到使用 RR 的高优先级队列，避免了被阻塞。 |
| **优先级调度** (单级)   | **饥饿问题：** 低优先级任务可能永远得不到执行。**刚性问题：** 对所有任务类型（交互式/计算型）使用同一套优先级规则，缺乏灵活性。 | **缓解饥饿：** 引入**队列间时间片分配**机制，保证低优先级队列获得最小份额的 CPU 时间，避免永久饥饿。**结构化分类：** 提供了**多套优先级**。系统优先级最高，交互式优先级次之，批处理最低，实现了**分层隔离**。           |
| **RR** (时间片轮转)   | **开销问题：** 时间片太短会导致**上下文切换开销过大**，浪费 CPU 资源，降低**吞吐量**。                  | **分层时间片：** 在**高优先级队列**中，使用**短时间片**的 RR 来保证**响应时间**。在**低优先级队列**中，使用**长时间片**的 RR（或 FCFS）来减少切换开销，从而**提高吞吐量**。                     |

总的而言，MLQ解决了单级调度算法很多不够灵活和平衡的问题，对具体情况作具体分析，使得整体效率提高

### 不足

1. 低优先级存在严重饥饿问题，由于分级制度的僵化，只要相对高优先级的任务存在就永远无法执行到低优先级任务
2. 初始化困难，需要对任务进行分类并指定专门的算法

---

## 多级反馈队列调度算法

MLQ虽然做了分级，存在许多不足，因此多级反馈队列算法对其进行了如下改进：增加“老化”机制，当低优先级任务长时间等待时会提高优先级，进入较高优先级队列，减缓饥饿；采用动态优先级，根据任务的行为预测其种类，改变其优先级

### 动态优先级

在MLQ或者优先级调度算法中，队列执行顺序高度依赖于初始化的优先级，但是操作系统并不真正知道任务的种类，一些计算密集型的任务可能初始优先级过高导致吞吐量下降

因此我们希望通过一些方法来推测任务的种类，从而更合理的组织运行队列：对于SJF算法，我们通过估计运行时间来安排顺序，借鉴SJF算法，MLFQ通过任务的行为判断其种类

举个例子，如果一个进程一直用到时间片结束才中断，说明该进程可能为计算密集型的任务，优先级应该降低；相反如果该进程总在用尽时间片前就触发I/O中断，说明该进程可能为I/O频繁型，优先级应该升高

### 老化机制

不管是SJF还是优先级的抢占式算法，低优先级的任务总是会面临饥饿问题，即一直无法运行

因此我们希望在保证低优先级任务少占用CPU时间的同时，又能不至于饿死，于是我们计算一个进程的等待时间，当等待时间达到一定值时提高该任务的优先级，从而缓解饥饿问题

同时，MLQ中的队列间调度太霸道，只要高优先级队列不为空，低优先级就始终得不到运行时间，于是我们调整一下队列间调度，将时间片中较小比例分配给低优先级队列，公平性（加权相对公平）也得到了保证

### 公平性问题的探讨

不同的调度算法实现了不同的公平性，时间片轮转保证了绝对公平性，但是上下文切换开销大；SJF算法吞吐量理论最大，实现了效率公平性；完全公平调度基于优先级分配时间，实现了相对公平性

### 进程类型的推测方法

分为两种，一种根据作业资源需求（包含预测所需时间、I/O请求数和内存需求）和历史记录来判断；一种根据运行时资源占用情况（主要是CPU占用）来判断

---

## 长程、中程、短程调度

可以将调度根据执行先后分为以上三种调度

### 长程调度：准入判断

在作业进入就绪队列前，长程调度需要作如下判断：就绪队列中的CPU密集型和I/O密集型的比例以及总任务数，还有当前作业的类型

长程调度的任务：限制并发数量，避免因频繁切换陷入“颠簸”状态；保证混合平衡，避免CPU密集型和I/O密集型失衡

### 中程调度：内存管理

内存资源宝贵，阻塞态、就绪态进程也会占用内存，因此对于等待I/O时间较长的、或者优先级很低的任务，操作系统会将其暂时换出（swap out）到磁盘中

中程调度的任务：控制内存资源的占用，控制多道程序设计度

注意：换出换入操作涉及磁盘读写，开销很大，所以如果不是长时间I/O等待，一般不会将阻塞态任务挂起；同理，对于就绪态的任务，只要系统内存压力没有太大，对其的挂起操作会更谨慎；虽然进程池也在磁盘中，但是挂起区的磁盘区域是单独的，中程调度没有权限将任务踢回进程池

### 短程调度

真正执行调度算法的部分，根据既定调度算法选出就绪队列中应该先被执行的一个，并进行上下文切换，使其进入运行态

注意：对于DLFQ中绝大多数队列都是按FIFO结构组织的，即按队列结构组织，如果发生优先级变动，则插入到上一级/下一级队列的队尾，这样对于短程调度而言就不需要每次对队列进行重排，取出队头元素即可；对于极高优先级队列，往往采用堆来组织

### 对于不同优先级队列采用不同结构的探讨

上文提到绝大多数队列按FIFO结构组织，这是因为这些队列对响应时间、吞吐量等参数的敏感度没有那么高，相同优先级内部就按FCFS或者RR算法调度即可，FIFO结构插入弹出时间复杂度最佳

而高优先级队列对吞吐量和周转时间要求极高，所以往往采用SJF算法调度，这就要求在新任务进入就绪队列时要按估计时长放在合适位置，并且频繁弹出最小元素，所以此时堆的结构最能满足需求

---

## 调度算法实例

### UNIX动态优先数算法

算法特征：动态计算优先数，优先数=CPU使用率/2+基础优先级+nice值，其中CPU使用率反映任务的特点及饥饿度，nice值给人为动态调控进程提供接口，是对朴素优先级调度算法的动态优化

优点：提高了朴素优先级算法的公平性和灵活度

缺点：作用范围受限，只在UNIX优先级队列中的“普通队列”内部使用；计算开销相对大

注意：CPU使用率的计算采用衰减平均值，每次计算都会对该值就行加权平均，即：新使用率=α*本次使用率+（1-α）*原使用率

补充：UNIX操作系统采用的是多级调度结构，对于不同的优先级队列采用不同的调度算法，而动态优先级队列用于其中的普通队列，满足一般任务对CPU资源竞争的需求，并不适用于所有队列

### Solaris综合调度算法

调度结构：实时任务→内核任务→用户态

特点：模块化，可自定义调度算法

---

## 多处理器架构

### 分类：

按功能对等性分类：UMP（对称多处理）、AMP（非对称多处理）

按内存访问方式分类：

UMA（统一访问内存）：一整块内存，每个CPU访问延迟相同

NUMA（非统一访问内存）：内存软分区，CPU访问自己辖区的速度快，但是仍可访问别的内存区块

NORMA（无远程内存访问）：内存硬分区，区块之间只能通过消息传递交换信息，不可直接访问

### 处理器亲和性：

除了UMA，NUMA和NORMA都是访问本地内存/缓存的开销小得多，所以对于同一个进程而言，如有可能，我们总希望他由上一次执行它的CPU继续执行，这就是处理器亲和性

软亲和性（动态亲和性）：调度器“建议”在同一个CPU上执行该任务，但是如果该CPU负载过高，可能将其移至另一个CPU执行

硬亲和性（静态亲和性）：手动“规定”该任务只能在特定的CPU集合上运行，即使这些CPU负载很高

### 多处理器调度的根本矛盾

亲和性和负载均衡之间的矛盾：我希望减少进程迁徙的开销，即尽可能让一个进程在同一个CPU内运行和等待；同时我也希望每个CPU的负载接近，不要出现过分拥挤或空闲的情况

解决方案：

1. 软亲和性：优先考虑亲和性，但是当负载过重时允许进程迁移
2. 工作窃取：在每个周期对负载情况进行检查之后，最空闲的CPU会窃取最忙碌的CPU的若干任务
3. 有选择的迁移：当出现负载失衡时优先迁移优先级较低、或近期未改变缓存内容的任务

为了判断是否进行工作窃取，调度器会通过比较负载均衡收益与亲和性损失的开销之间的大小来决定是否执行窃取，对于窃取对象，一般直接选择被窃取CPU等待队列中的末尾任务（一般优先级较低，缓存热度也较低）

为了实用性，实际操作中亲和性开销被设定为一个阈值（而非根据任务进行估计），仅当最空闲和最忙碌的CPU负载差距达到阈值时才执行，即仅当负载非常不均衡时再被迫进行迁移
