---
title: 进程线程模型
author: Allwayso
date: 2025-12-20
status: Completed
---

---

## 进程定义和结构

定义：进程就是一个正在运行的程序

结构：栈，堆、静态数据区以及代码段（text code）

### 栈（高地址）

作用：函数调用以及局部变量，向低地址增长

### 堆（低地址）

作用：动态分配内存；跨越函数生存期（该内存空间不随函数结束销毁）

举例：vector等动态容器通过堆动态改变大小；new操作将数据存入堆中，生存周期不受函数约束

注意：堆栈属于动态、短期数据区，其状态和大小都会发生变化

注意：堆栈相互补充，栈负责快速自动的短期数据存储，占用连续、有序的内存空间；而堆负责手动、生存期灵活的内存分配，占用无序、离散的内存空间。两者相互配合，维护程序的高效性和灵活性

### 静态数据区

已初始化、未初始化的全局变量、静态变量，大小已经确定

### 代码段

存储程序的所有机器指令以及只读常量，通常设为只读，避免被修改

---

## 进程状态

进程在新建后、终止前存在三个状态，即就绪、运行、等待

### 进程状态切换情境

1.就绪→运行：切换到该进程，从上次终止的地方开始运行

2.运行→就绪：时间片用尽/被高优先级进程打断/处理更紧急的任务，切换到另一进程

3.运行→等待：I/O中断或者wait()指令等情况，被迫切换到另一进程，原进程进入等待态

4.等待→就绪：当I/O操作结束后，发出指令，进程再次进入就绪态，回到调度队列中等待

<details> 
  <summary style="color: #2196F3; cursor: pointer;">个人理解</summary>
1.当新建一个进程的时候，PCB和页表结构已经被创建好，即刻进入就绪态
2.结束一个子进程的时候，会先进入僵尸态，主要保留退出码（标识进程退出原因）、PID和PPID以及资源使用报告，当父进程调用wait()函数，发现子进程已经结束，提取以上信息后彻底销毁；分步销毁是为了诊断子进程死因以及使父子进程同步（父子进程原本是异步的，即没有先后关系）
3.wait()函数：当父进程调用wait()函数，即刻进入等待态，如果子进程已经结束，则父进程提取僵尸态的子进程的信息，分析死因后变回就绪态；如果子进程没有结束，则父进程仅当子进程结束后才会运行
4.等待态不能直接变为运行态，因为切换到该进程仍然无法运行（仍在处理I/O或者等待某一指令），必须经过就绪态；就绪态不会变回等待态，因为进入等待态是由于其主动发出了一个等待外部事件的请求，而就绪态进程不在运行，自然不能发出请求，也自然不能变回等待态
5.如果父进程结束时仍未调用wait，则已经运行结束的子进程称为僵尸进程，仍在运行的称为孤儿进程，此时孤儿进程和僵尸进程的父进程都会变为init，init在接管后回快速调用wait，但主要目的不是提取信息，而是为了收回内存
 </details>

---

## 线程：

操作系统调度的最小单元，是一个轻量化的进程

结构：与进程共享堆、代码段、页表等，仅私有寄存器集合和栈指针（TCB)

注意：进程并没有自己的“公共”寄存器，所谓进程上下文切换其实保存的是正在运行的线程中的寄存器状态

线程与子进程的区别：

1. 继承情况：子进程继承时采用COW机制，新建了一个页表，对于同一个变量指向同一个物理内存地址，仅当修改某变量时，创建该变量对应物理内存页的副本并对副本修改，并不会复制整个内存空间；线程直接共享进程的页表，无需新建页表
2. 共享与隔离：线程有其局部变量和栈指针，但是对于需要共享的数据都存放在进程的堆中，同时线程之间也会相互通信，共享程度高；子进程与父进程高度隔离，修改变量互不影响
3. TCB和PCB的区别：TCB仅保存寄存器集合和栈指针以及TID等消息，提示线程运行到哪一步；而PCB包含堆、代码段、全局变量等，提示进程拥有哪些资源

### 用户级线程与内核级线程对比

| **特性**      | **用户级线程 (ULTs)**                                 | **内核级线程 (KLTs)**                         |
| ----------- | ------------------------------------------------ | ---------------------------------------- |
| **管理者**     | 用户空间的线程库（如 Pthreads, Java 虚拟机）                   | 操作系统内核                                   |
| **对内核可见性**  | 不可见。内核只看到一个或少数几个进程/核心线程                          | 可见。内核可以调度和管理每个单独的线程                      |
| **创建/销毁开销** | 极低。只是用户空间的操作，不涉及系统调用                             | 较高。每次操作都需要进行系统调用，涉及内核态的上下文切换             |
| **调度**      | 用户空间线程库进行。调度算法可以自定义                              | 操作系统内核进行。调度算法由 OS 决定                     |
| **阻塞问题**    | 严重。一个线程调用阻塞的系统调用（如 I/O），会阻塞整个进程（所有用户级线程）         | 无。一个线程阻塞，内核只会调度该进程中的其他线程继续执行             |
| **多核利用**    | 差。无论有多少 CPU 核心，一个进程中的所有 ULT 只能运行在一个内核线程上，无法实现真并行 | 优秀。内核可以将同一进程的不同 KLTs 分配给不同的 CPU 核心，实现真并行 |
| **上下文切换**   | 极快。只是在用户态保存/恢复寄存器，没有昂贵的内核切换                      | 较慢。每次切换都需要从用户态切换到内核态                     |
| **适用场景**    | I/O 非阻塞的计算密集型任务，或线程切换开销要求极高的场景                   | I/O 阻塞频繁、需要充分利用多核 CPU 的通用应用（如 Web 服务器）   |

从用户级线程到内核级线程：

早期用户级线程模型的诞生是为了解决等待资源时整个进程停滞的问题，所以设计为当资源未准备好时切换到同一进程的另一线程，这一活动是在用户态进行的，避免了内核状态切换和系统调用的开销（在早期十分高昂），同时也使得线程更为灵活（可以在用户空间使用线程库编写，适配各种操作系统）；但是同样是因为在用户态进行，当等待I/O操作等涉及系统调用的时候，操作系统不得不切换到内核态，而内核对用户态的线程没有权限，从而只能将其所在的进程从运行态变为阻塞态，导致该进程的所有线程阻塞。所以当多核CPU发展起来的时候，真并行和解决I/O阻塞的需求推动着内核级线程的发展，从而最终线程的管理者变成了操作系统。

---

## 多线程模型

如果你使用的是底层系统 API，你创建的就是 KLT；如果你使用的是高级语言的并发抽象，你创建的通常是用户级线程，然后由语言运行时负责映射到 KLT 上

1. 多对一模型：多个用户级线程映射到一个内核级线程上，依旧会发生阻塞问题，基本淘汰
2. 一对一模型：底层操作系统API当创建线程时直接创建的就是内核级线程
3. 多对多模型：高级语言的并发抽象，将多个用户态进程映射到少量内核级线程上

### 多对多模型处理I/O阻塞（非交互式）的机制：

1. 用户态调度器发现I/O调用，立即拦截，将I/O句柄存入调度器的监控目录
2. 将该线程状态变为阻塞态，取消其对内核级线程的映射
3. 仅当出现两种情况时进入内核态，向内核提交监控目录：该请求为第一个请求；没有别的用户级线程可用。只要内核的监控目录中有任意请求已经完成，立即切换回用户态，标注对应进程状态为就绪态，映射到空闲的KLT中
4. 如果无需进入内核态，则切换另一准备好的线程，保持KLT时刻忙碌

注意：

1. I/O操作在内核接收到句柄后立刻启动，该操作为硬件操作，不占用CPU或者KLT；
2. 对于交互型I/O，如获取鼠标或者键盘输入时，调度器会立即切换到内核态，将该请求发送给内核，此时KLT进入等待，从而保持低延迟
