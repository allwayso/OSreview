---
title: 死锁
author: Allwayso
update: 2025-12-22
status: Completed
---

---

## 死锁定义

若干个线程无限期的等待对方的资源，或者一个线程递归调用一个有锁的函数

---

## 死锁发生的条件（Coffman条件）：

1. 互斥：资源的占有必须是互斥的
2. 持有并等待：进程已经占有了一个资源，但又希望获得另一个资源
3. 资源非抢占：已经分配给一个进程的资源不得被抢占
4. 循环等待：即等待链条构成一个环路

---

## 死锁预防

| **破坏的必要条件**                     | **策略名称**   | **实现方式（如何破坏条件）**                         | **主要优点**                     | **主要缺点 / 限制**                        |
| ------------------------------- | ---------- | ---------------------------------------- | ---------------------------- | ------------------------------------ |
| 1. **互斥条件**                     | **资源共享**   | 将资源从独占（非共享）改为共享模式。                       | 彻底消除互斥引发的死锁问题，提高资源利用率。       | **适用性极差。** 多数资源（如写入权限、打印机）本质上不可共享。   |
| 2. **占有且等待**                    | **一次性请求**  | 进程必须在执行前，一次性申请所有所需的资源，否则不分配任何资源。         | 避免了进程在占有资源的同时等待其他资源的局面。      | **资源利用率低：** 进程可能长时间占有暂时不用的资源。        |
| **可能导致饥饿：** 资源充足的大进程难以得到满足。     |            |                                          |                              |                                      |
| 2. **占有且等待**                    | **请求前释放**  | 进程请求新资源时，必须先释放当前占有的所有资源。                 | 允许进程分阶段执行，比一次性请求更灵活。         | **实现复杂：** 需要保存和恢复进程状态，增加系统开销。        |
| **效率低下：** 频繁的申请和释放操作。           |            |                                          |                              |                                      |
| 3. **不可剥夺**                     | **允许剥夺**   | 当进程申请新资源失败时，必须释放已占有的资源；或允许系统剥夺低优先级进程的资源。 | 提高了资源的分配灵活性。                 | **实现代价高：** 对某些资源（如打印机、内存）难以或不适合实现剥夺。 |
| **可能导致饥饿：** 资源被反复剥夺的进程可能无法完成任务。 |            |                                          |                              |                                      |
| 4. **环路等待**                     | **资源有序分配** | 对所有资源类型进行编号排序，并规定进程必须按编号**递增**的顺序请求资源。   | **实现简单，行之有效。** 理论上能彻底破坏环路等待。 | **降低并发性：** 限制了进程对资源的请求自由度。           |
| **编程不便：** 程序员需要严格遵循资源编号顺序来编码。   |            |                                          |                              |                                      |

---

## 死锁避免

### 安全状态：

当系统按一种顺序组织进程队列，使其满足：一个进程一次获得所有所需资源，在全部使用完之后释放已占有资源和所需资源，使得所有进程最终都能满足需求，称这种状态为安全状态

### 安全算法（银行家算法）：

数据结构：available[M]（可用资源）,need[N][M]（进程要求资源）,finished[N]（是否完成）,allocation[N][M]（占有资源）

算法执行：

1. 初始化work[M]=available,finished={false}
2. if (need[i]≤work&&finished[i]==false) work+=allocation[i],finished[i]=true;
3. finished全为true时满足安全算法，说明找到安全序列

优点：

1. 资源利用率高
2. 不需要预防任何死锁条件
3. 安全性高，适用于强实时系统

缺点：

1. 算法开销大，每个请求都要判断是否安全
2. 不可能预知所有need

---

## 死锁检测

允许死锁发生，在一定条件下对其检测，判断是否有死锁发生

### 检测策略：

1. 每次资源分配时检测，退化为死锁避免
2. 定时检测
3. CPU利用率下降时检测

### 检测算法：

数据结构+=request[N][M]

1. if(request[i][j]≤available[i][j]&&request[i][j]≤need[i][j]) 
2. allocation[i][j]+=request[i][j],available[j]-=request[i][j]
3. if(Safety()) goback;else continue;

---

## 死锁中止

采取进程终止或资源抢占来终止死锁

### 进程终止

策略1：终止死锁中的所有进程

策略2：逐个终止进程，检测是否解除死锁

### 资源抢占

1. 选择牺牲者
2. 让抢占者抢占牺牲者已占有的资源
3. 牺牲者进程回滚至可恢复位置

---

## 鸵鸟策略

允许死锁发生并且不处理，直接采取系统重启解决

死锁极少发生且重启成本不太高时可用
