---
title: 进程同步与互斥机制
author: Allwayso
update: 2025-12-22
status: Completed
---

---

## 问题概述

对于并发的操作系统而言，两个线程可能同时访问一个共享的内存空间，并都对其进行操作，这时候由于先后顺序无法预测，会导致出乎意料的结果

---

## 发生原因

根本原因：并发执行与共享内存的矛盾

直接原因：

1. 竞争机制：对内存空间的操作取决于精准时序
2. 原子性破坏：当对临界区的操作不是原语时，由于随时可能被打断，语句执行不完整
3. 执行顺序不确定：并发操作和调度器调度使线程对内存空间的操作顺序不确定

---

## 互斥算法的条件

1. 互斥进入 有进程在对数据继续操作时，其他进程不得进入临界区
2. 空闲让进 没有进程在临界区操作、且有进程在等待时，必须允许一个进程进入
3. 有界等待 一个进程开始等待后，其他进程进入临界区的次数应该是有限的

---

## 解决方案

### 软件尝试（Peterson算法）

peterson算法的前身：

1. 只使用turn变量来保持互斥：
   
   满足互斥；不满足空闲让进和有界等待（turn初始化为0，且没有进程p1时，p0无限等待

```c
// thread P0
while(turn==1);//轮到对方时忙等
//critical section
turn=1;//控制权交给对方
```

2. 类似的，如果只用flag标识意愿，则能满足空闲让进和有界等待，但是不满足互斥

3. Peterson算法：通过谦让和意愿解决了单线程互斥问题

```c
boolean flag[2];//线程i的意愿
int turn;//谦让，优先权让给对方

// 初始化：
flag[0] = false;
flag[1] = false;
turn = 0;

#define P_i 0
#define P_j 1

void Process_P0() {
    while (true) {

        flag[P_i] = true; 
        turn = P_j; 
        //当对方有意愿且优先权在对方时，忙等待
        while (flag[P_j] == true && turn == P_j) {
        }

        // 临界区 (Critical Section)

        flag[P_i] = false;

        // 剩余区 (Remainder Section)
    }
}

#define P_i 1
#define P_j 0

void Process_P1() {
    while (true) {

        flag[P_i] = true; 
        turn = P_j; 

        while (flag[P_j] == true && turn == P_j) {
        }

        // 临界区 (Critical Section)

        flag[P_i] = false;

        // 剩余区 (Remainder Section)
    }
}
```

#### 软件互斥算法的失败

1. 忙等待 只能通过while循环等待条件满足，浪费大量CPU时间
2. 指令重排 现代CPU追求性能，可能对指令进行重排，导致软件算法不能正确执行
3. 硬件依赖 即使所依赖的load和store是原子性操作，任何更复杂的操作都会破坏整体原子性
4. 功能薄弱 只能满足两进程互斥，对于多进程互斥效率低下且繁琐

综上所述，软件是错的，硬件是对的

#### 原子指令

TSL指令（TestandSet）：读取锁的布尔值，设置为true，返回旧值

TSL实现自旋锁：在获得锁的过程中while(TestandSet())保证当锁被释放时才能继续，否则自旋

CAS指令（CompareAndSwap)：读取A，当符合预期B时将A修改为C，返回空指针；否则返回A。

CAS不仅能实现自旋锁结构，还能实现free-lock结构，以下是CAS实现无锁栈的实现：

```c
void push(const T& value) {
        Node<T>* new_node = new Node<T>(value);
        Node<T>* old_head; // 期望值 (expected)

        do {
            old_head = head.load(); // 1. 读入当前栈顶 (期望值)
            new_node->next = old_head; // 2. 计算新值：新节点 next 指向旧栈顶

            // 3. CAS 尝试：期望 head == old_head，成功则更新 head 为 new_node
            // 失败时，old_head 被更新为 head 的最新值
        } while (!head.compare_exchange_weak(old_head, new_node));
    }

    // Pop 操作 (出栈)
    bool pop(T& result) {
        Node<T>* old_head; // 期望值 (expected)
        Node<T>* new_head; // 新值 (desired)

        do {
            old_head = head.load(); // 1. 读入当前栈顶 (期望值)
            if (old_head == nullptr) {
                return false; // 栈为空
            }
            new_head = old_head->next; // 2. 计算新值：新栈顶是旧栈顶的 next

            // 3. CAS 尝试：期望 head == old_head，成功则更新 head 为 new_head
        } while (!head.compare_exchange_weak(old_head, new_head));

        result = old_head->data; // 获取数据
        delete old_head;         // 释放内存
        return true;
    }
};
```

注意CAS无锁栈并不会一直自旋，如果在do操作过程中head被别的进程修改，则返回值为true，再次进入do，old_head被更新为新的head

只要有一次不发生冲突，就能跳出while循环，所以CAS适合无锁环境

除此之外，还有XCHG、Fetch_and_Add、atomic load、atomic store等原子指令

**但是**直接用原子指令实现进程控制比较复杂，而且不同操作系统的原子指令不同，缺乏可移植性、实现复杂

所以在内核中对原子指令做了封装，实现了信号量、互斥锁等机制，

注意：虽然这些机制宏观上相对复杂，但依然保证了原子性：1. 内部指令通过原子指令实现 2. 在信号量、互斥锁内部代码用底层CAS/禁用中断保证互斥

### 互斥锁

对于函数中一个代码段，我希望同时只有一个进程能够对其操作，这就是互斥锁的功能

特点：

1. 锁的acquire和release都是原语，因为锁本身不应触发进程同步问题
2. acquire和release标定了临界区的范围
3. 先执行acquire会将锁的状态变为false，在release之前其他执行该代码段的线程都会被阻塞，进入等待队列

#### 锁的种类：

按实现策略分：乐观锁（读不加锁，写加锁） 悲观锁（只要访问共享数据都加锁）

悲观锁适用于读写冲突严重的情境，读写冲突不明显时乐观锁即可（乐观锁不采取阻塞机制）

按行为和用途分：

**自旋锁**：线程被阻塞时并不休眠，而是进入忙等待模式，一直试图acquire

用于临界区非常简洁、多核操作系统，期望等待时间极短，用CPU时间换取上下文切换开销

**递归锁**：记录锁的拥有者，当其再次acquire时允许其再次获得一把锁，当锁的数量为0时清空拥有者

用于解决有锁函数的递归调用导致的死锁问题，但是不能解决循环等待导致的死锁

### 信号量

信号量是控制进程间协作的机制，通过PV操作提供资源和读取资源

#### 信号量的基本操作：

PV操作，保证原子性，是信号量保持原子性的基础

P操作（wait+down）：

1. 测试信号量是否为0
2. 若0，线程阻塞，执行wait
3. 若非0，信号量-1

V操作（signal+up）：

1. 信号量+1
2. 若有线程因为该信号量为0而阻塞，则唤醒

#### 信号量的功能

1. 互斥 二值信号量避免数据竞争
2. 并发 计数信号量维护并发有序

---

## 具体情境

### 消费者-生产者问题（理解信号量的经典问题）：

问题简介：缓存区大小有限，读写不能同时操作，不能读空数据，不能上溢

我们通过三个信号量（mutex，full，empty)来维护：

1. mutex互斥锁(二值信号量）：处理同步访问，当有消费者/生产者在仓库中时，试图进入仓库的先进入等待队列
2. 生产者执行放入操作时，full执行V操作，empty执行P操作
3. 消费者执行取出操作时，full执行P操作，empty执行V操作

这样就保证了有界缓冲区不会出现上下溢出

```c
int max_size=10;
mutex mtx=1;
semaphore full=0;
semaphore empty=10;

void productor_process(){
    P(empty);//注意：先acquire再P可能会导致死锁
    acquire(mtx);
    InsertItems();
    release(mtx);
    V(full);
    }

void consumer_process(){
    P(full);
    acquire(mtx);
    TakeItems();
    release(mtx);
    V(empty);
    }
```

### 读者、写者问题

问题简介：写者互斥、读者共享

具体而言：

当有读者在读时，写者必须等待当前并发读者读完后才能写；

当有写者在写时，读者必须等待写者写完才能写；

当有读者在读，有写着等待后又有新的读者到来时：

1. 若采取读者优先，则读者立即开始读
2. 若采取写者优先，则在新的读者排在写者后面
3. 若采取公平锁，则读者写者按FCFS顺序排队

**信号量实现(读者优先）：**

1. 三个信号量：写者锁rw_mutex，读者数count,计数锁mutex（保证对count的访问不冲突）
2. 写者行为：wait(rw_mutex);临界区;signal(rw_mutex);
3. 读者行为： 

```c
void reader_process(){
    while(true){
    wait(mutex);//获取计数锁
    count++;
    if(count==1){
        wait(rw_mutex);//如果为唯一读者，获取写者锁，不让写者进入
    }
    signal(mutex);
    /*
        临界区
    */
    wait(mutex);
    count--;
    if(count==0) signal(rw_mutex);//如果没有读者，释放写者锁
    signal(mutex);
}
```

**读写锁实现**：对信号量的封装

```c
std::shared_mutex rw_lock_;
std::shared_lock<std::shared_mutex> lock(rw_lock_);
std::unique_lock<std::shared_mutex> lock(rw_lock_);
```

### 哲学家就餐问题

问题描述：五个哲学家坐在圆桌上，五个筷子放在他们之间，哲学家只有两个状态，思考和就餐，必须同时拿起左右两个筷子才能就餐

死锁风险：当五个哲学家同时先拿右边的筷子，再试图拿左边的筷子时，会形成死锁

解决方案：

1. 最多四人就餐：设置一个信号量room=4，当其为0时第五个试图进入的哲学家必须等待
2. 破坏循环：对某一个哲学家要求其先拿左边筷子，再拿右边
3. 奇偶法：类似破坏循环，奇数号哲学家先拿左边，偶数号先拿右边

### 睡眠的理发师

问题描述：

1. 当没有顾客的时候，理发师睡觉；当理发师剪完一个顾客时，检查等待区是否有顾客，若有则叫出第一个顾客，开始剪头发
2. 当顾客进入理发店，发现等待区已满时，离开理发店；否则坐在等待区，若理发师在睡觉，则叫醒他

解决方案：

```c
const int N_chairs=5;
mutex mtx=1;//保证对waiting_c的互斥访问
int waiting_c=0;
semaphore customers=0;
semaphore barber=0;

void barber_process(){
    while(true){
        P(customers);//没有顾客时，阻塞在此
        acquire(mtx);
        waiting_c--;//有顾客时，叫号
        V(barber);//向顾客声明，理发师空闲
        release(mtx);
        cutHear();
    }
}
void customer_process(){
    acquire(mtx);
    if(waiting_c>=N_chairs) release(mtx);
    else{
        waiting_c++;//排队
        V(customers);//声明已有顾客
        release(mtx);
        P(barber);//理发师忙时，阻塞在此；空闲时，理发师状态变为忙碌
        getHairCut();
        }
}
```
