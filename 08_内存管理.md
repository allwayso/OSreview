---
title: 内存管理
author: Allwayso
update: 2025-12-29
status: Updating
---

---

## 为什么要做内存管理

内存空间有限，并发程序需要同时、互相隔离、高效地使用大量内存

---

## 派生问题

1. 分配：空间管理，让多个程序能高效共存 
2. 隔离：安全保护，防止程序互相干扰或修改操作系统 
3. 共享：提高利用率，让不同进程使用相同的代码段 
4. 扩展：突破物理限制，让大程序能在小内存上运行 

---

## 基础概念

### 虚拟地址空间

为进程创建一片从0开始的、连续的虚拟地址

目的：

1. 代码与位置解耦：程序在哪都能运行，不依赖于硬编码的物理地址
2. 程序员与硬件细节解耦：不需要硬编码程序物理地址
3. 进程与进程解耦：代码之间互相不知道物理地址，实现隔离

### 地址重定位

将虚拟地址映射到物理地址上

静态重定位：进程在创建时确定了一个固定的偏移量，此后不再改变，物理地址相应不变
动态重定位：用基址寄存器存储偏移量，可以改变，物理地址相应改变

### 内存保护

检查逻辑地址是否超过界限寄存器中存储的最大长度，实现进程间物理地址的硬隔离

> 硬隔离：界限寄存器的权限为内核级，程序无法改变

重定位步骤：

1. 安检：检查是否越界，如果越界就抛出段错误，中断进程
2. 翻译：计算实际物理地址

### 早期内存扩展技术

早期内存容量很小，为了在有限内存中运行较大程序，早期使用了覆盖和交换两种技术来扩展内存

**覆盖技术**：
将较大的程序分块，分为常驻区和覆盖段，非核心代码段只在使用时放入覆盖段
缺点：需要手动分配内存，编程复杂度极高；频繁读写外存，运行速度受限

**交换技术**：
将暂时不需要运行的整个进程换出到交换区，待运行时再换入内存，由操作系统自动调度
缺点：颗粒度太粗，只要进程中有一小部分在运行，也要将整个进程换入内存

---

## 基本内存管理方案

### 1. 固定分区 (Fixed Partitioning)：简单但浪费

这是最早期的多道程序存储管理方式。它将物理内存划分为若干个固定大小的分区，每个分区只装入一个作业。

- **特点**：分区的大小和边界在系统初始化时就已确定。

- **演进痛点**：
  
  1.内碎片严重：如果分区是 10MB，而程序只有 2MB，剩下的 8MB 就被浪费了。
  
  2.无法运行大程序：如果所有分区都只有 10MB，那么 11MB 的程序就无法运行。

- **评价**：管理极其简单，但由于程序大小与分区大小不匹配，导致了极大的空间浪费。

### 2. 动态分区 (Dynamic Partitioning)：灵活但碎片

为了解决固定分区的死板，动态分区根据进程的实际需求，“按需分配”。

- **特点**：程序需要多少内存，就从空闲内存中切出多少给它。

- **演变核心**：引入了FF，NF，BF，WF等分配算法。

- **演进痛点**：
  
  1.外碎片问题：随着进程频繁换入换出，内存中会产生大量细小的、不连续的空闲空间（如 1KB 的缝隙），这些缝隙小到无法容纳任何新进程。
  
  2.紧凑成本高：虽然可以通过“内存紧凑（拼图）”来消除碎片，但数据搬移极其耗费 CPU 性能。

- **评价**：解决了内碎片，却带来了难以根治的外部碎片。

> 内碎片：占着茅坑不拉屎。进程用不完固定的内存块，多余的部分又不能被别的进程使用
> 外碎片：空闲很多但太零碎。非连续、细小的内存空间无法被任何进程利用

| **算法名称**      | **算法思路**                              | **优点**                                  | **缺点**                                      |
| ------------- | ------------------------------------- | --------------------------------------- | ------------------------------------------- |
| **首次适应 (FF)** | 从空闲分区链的**头部**开始找，满足大小的第一个空洞就分配。       | **速度最快**。它倾向于优先利用低地址空间，从而在高地址保留大片连续空闲区。 | 低地址部分会产生很多细小的**外碎片**，每次查找都要经过这些碎片，增加开销。     |
| **循环首次 (NF)** | 从**上次查找结束的位置**开始往下找，直到找到满足要求的第一个空洞。   | 空间分布更均匀，查找分区的**平均起始时间短**，不会让碎片集中在头部。    | **破坏了大空间**。因为它雨露均沾，导致高地址的大空闲块也会被切碎，大作业难进来。  |
| **最佳适应 (BF)** | 搜索全表，挑选能满足要求的**最小**空闲分区（通常按容量递增排序查找）。 | 每次只动“刚好够”的块，**最大限度保留了大的连续空闲区**，方便后续大作业。 | **碎片问题最严重**。剩下的空间往往极其微小（如几KB），成了谁也用不了的“药渣”。 |
| **最坏适应 (WF)** | 搜索全表，挑选能满足要求的**最大**空闲分区（通常按容量递减排序查找）。 | 分配后剩下的空闲区依然很大，**不容易产生细小碎片**，利用率较好。      | **杀伤力大**。很快就会把内存里最大的“独苗”空间给切碎，导致大程序进入时无处安身。 |

> 这些分配方法原本是为了分配物理内存，在采用页式管理方法后不再需要这个功能，但是虚拟内存空间的分配仍然需要这些分配算法的变种

---

### 3. 页式管理 (Paging)：连续到非连续

页式管理是内存管理的一次**范式转移**。它放弃了“程序必须存放在连续内存”的要求，将内存和程序都“切碎”了。

- **特点**：
  
  1.把物理内存分成固定大小的“块”（Frame）。
  
  2.把程序的逻辑空间分成相同大小的“页”（Page）。
  
  3.通过页表(Page Table) 将连续的页映射到离散的块。

- **解决的问题**：彻底消除了**外部碎片**，因为任何一个空闲块都可以分配给任何一个页。

- **评价**：实现了内存的高度自动化和统一管理。但是自动分块的代价是逻辑性的缺失，主要有以下几个问题：
  
  1.对不同性质的程序难以采取不同的保护策略（比如同一页的程序中同时有不能修改的指令和必须修改的全局变量）
  
  2.不能满足具有增长需求的数据结构的需要（如堆栈）

> 页式管理与虚拟内存的关系：注意到页式管理中出现了“逻辑空间”概念，也就是说这个时候进程的逻辑地址和物理地址开始分离，将程序员从直接操控物理地址中解放出来。
> 1.通过将程序分页，只关注页的连续的逻辑地址，把分配物理地址的任务交给页表寄存器实现
> 2.不再手动从磁盘调取程序块，由操作系统自动调页，把不在内存中的一页搬入内存

---

### 4. 段式管理 (Segmentation)：物理导向到逻辑导向

段式管理回到了“程序员”的角度，按照程序的逻辑功能来划分内存。

- **特点**：程序被划分为主程序段、子程序段、数据段、栈段等，每个段的大小不一。

- **解决的问题**：
  
  1.方便共享与保护：比如可以轻松设置“代码段”只读，“数据段”可读写。
  
  2.动态增长：某个段（如栈）需要扩张时，这种结构更加自然。

- **评价**：它更符合人类的编程习惯和安全管理需求，但由于段长不固定，它又带回了动态分区的**外部碎片**难题。

---

### 5. 段页式管理 (Segmented Paging)：权衡的产物

这是目前主流操作系统（如 Windows、Linux、macOS）普遍采用的终极方案，它结合了前两者的长处。

- **核心逻辑**：
  
  1. 先将程序按逻辑**分段**（满足逻辑保护、共享需求）。
  
  2. 再将每一个段内部**分页**（解决内存分配的外部碎片问题）。

- **流程**：逻辑地址 $\rightarrow$ 段表 $\rightarrow$ 页表 $\rightarrow$ 物理地址。

- **评价**：
  
  1.它既拥有段式的**逻辑完整性**（好共享、好保护）。
  
  2.又拥有页式的**物理规则性**（空间利用率极高）。
  
  3.虽然地址转换增加了查表开销（现代 CPU 通过 TLB 快表解决了此问题），但它是目前最完美的平衡点。

> 内存管理方式的演进过程也可以看成是颗粒度的问题，需要在管理成本，空间利用率（指内外碎片问题）和逻辑完整性之间取得平衡
> 
> 当颗粒度很粗的时候，管理成本低，逻辑完整性高，但是空间利用率差（固定分区）
> 
> 当颗粒度很细的时候，管理成本低，空间利用率高，但逻辑完整性差（页长极小的页式管理）
> 
> 当颗粒度固定的时候，管理成本低，逻辑完整性可能差，空间利用率可能差（页式管理）
> 
> 当颗粒度自由的时候，管理成本高，逻辑完整性高，空间利用率可能差（段式管理，动态分区）
> 
> 只有分配内存的大小、策略都合适的时候，才能兼顾三者（段页式）

---

## 虚拟页式内存管理

---

## 页面置换算法

---

## 虚存性能的影响因素

---

## 虚存相关技术
